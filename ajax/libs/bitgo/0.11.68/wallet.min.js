var TransactionBuilder=require("./transactionBuilder"),Address=require("bitcoinjs-lib/src/address"),HDNode=require("./hdnode"),Keychains=require("./keychains"),PendingApproval=require("./pendingapproval"),ECKey=require("bitcoinjs-lib/src/eckey"),Util=require("./util"),assert=require("assert"),common=require("./common"),networks=require("bitcoinjs-lib/src/networks"),Q=require("q"),_=require("lodash"),Wallet=function(e,t){this.bitgo=e,this.wallet=t,this.keychains=[],t["private"]&&(this.keychains=t["private"].keychains)};Wallet.prototype.toJSON=function(){return this.wallet},Wallet.prototype.id=function(){return this.wallet.id},Wallet.prototype.label=function(){return this.wallet.label},Wallet.prototype.balance=function(){return this.wallet.balance},Wallet.prototype.spendableBalance=function(){return this.wallet.spendableBalance},Wallet.prototype.confirmedBalance=function(){return this.wallet.confirmedBalance},Wallet.prototype.canSendInstant=function(){return this.wallet&&this.wallet.canSendInstant},Wallet.prototype.instantBalance=function(){if(!this.canSendInstant())throw new Error("not an instant wallet");var e=3;return("test"===this.bitgo.env||"dev"===this.bitgo.env)&&(e=1),this.unspents({minConfirms:e}).then(function(e){return _.sum(e,"value")})},Wallet.prototype.unconfirmedSends=function(){return this.wallet.unconfirmedSends},Wallet.prototype.unconfirmedReceives=function(){return this.wallet.unconfirmedReceives},Wallet.prototype.type=function(){return this.wallet.type},Wallet.prototype.url=function(e){return e=e||"",this.bitgo.url("/wallet/"+this.id()+e)},Wallet.prototype.pendingApprovals=function(){var e=this;return this.wallet.pendingApprovals.map(function(t){return new PendingApproval(e.bitgo,t,e)})},Wallet.prototype.get=function(e,t){e=e||{},common.validateParams(e,[],[],t);var r=this;return this.bitgo.get(this.url()).result().then(function(e){return r.wallet=e,r}).nodeify(t)},Wallet.prototype.createAddress=function(e,t){var r=this;if(e=e||{},common.validateParams(e,[],[],t),"safe"===this.type())throw new Error("cannot create an address for safe wallet; use .id()");var n=void 0!==e.validate?e.validate:this.bitgo.getValidate(),i=e.allowExisting;"boolean"!=typeof e.allowExisting&&(i="true"===e.allowExisting);var a=e.chain||0;return this.bitgo.post(this.url("/address/"+a)).send(e).result().then(function(e){return n&&r.validateAddress(e),e}).nodeify(t)},Wallet.prototype.validateAddress=function(e){common.validateParams(e,["address","path"],[]);var t=this,r=function(e){var r=/^\/[01]\/\d+$/;if(!e.match(r))throw new Error("unsupported path: "+e);var n=t.keychains.map(function(t){var r=HDNode.fromBase58(t.xpub);return r=r.deriveFromPath("m"+t.path+e),r.pubKey}),i=Util.p2shMultisigOutputScript(2,n),a=networks[common.getNetwork()];return Address.fromOutputScript(i,a).toBase58Check()},n=r(e.path);if(n!==e.address)throw new Error("address validation failure: "+e.address+" vs. "+n)},Wallet.prototype.addresses=function(e,t){e=e||{},common.validateParams(e,[],[],t);var r=[];if(e.details&&r.push("details=1"),"undefined"!=typeof e.chain){if(0!==e.chain&&1!==e.chain)throw new Error("invalid chain argument, expecting 0 or 1");r.push("chain="+e.chain)}if(e.limit){if("number"!=typeof e.limit)throw new Error("invalid limit argument, expecting number");r.push("limit="+e.limit)}if(e.skip){if("number"!=typeof e.skip)throw new Error("invalid skip argument, expecting number");r.push("skip="+e.skip)}if(e.sort){if("number"!=typeof e.sort)throw new Error("invalid sort argument, expecting number");r.push("sort="+e.sort)}var n="";r.length&&(n="?"+r.join("&"));var i=this.url("/addresses"+n);return this.bitgo.get(i).result().nodeify(t)},Wallet.prototype.stats=function(e,t){e=e||{},common.validateParams(e,[],[],t);var r=[];if(e.limit){if("number"!=typeof e.limit)throw new Error("invalid limit argument, expecting number");r.push("limit="+e.limit)}var n="";r.length&&(n="?"+r.join("&"));var i=this.url("/stats"+n);return this.bitgo.get(i).result().nodeify(t)},Wallet.prototype.address=function(e,t){e=e||{},common.validateParams(e,["address"],[],t);var r=this.url("/addresses/"+e.address);return this.bitgo.get(r).result().nodeify(t)},Wallet.prototype.freeze=function(e,t){if(e=e||{},common.validateParams(e,[],[],t),e.duration&&"number"!=typeof e.duration)throw new Error("invalid duration - should be number of seconds");return this.bitgo.post(this.url("/freeze")).send(e).result().nodeify(t)},Wallet.prototype["delete"]=function(e,t){return e=e||{},common.validateParams(e,[],[],t),this.bitgo.del(this.url()).result().nodeify(t)},Wallet.prototype.labels=function(e,t){e=e||{},common.validateParams(e,[],[],t);var r=this.bitgo.url("/labels/"+this.id());return this.bitgo.get(r).result("labels").nodeify(t)},Wallet.prototype.setWalletName=function(e,t){e=e||{},common.validateParams(e,["label"],[],t);var r=this.bitgo.url("/wallet/"+this.id());return this.bitgo.put(r).send({label:e.label}).result().nodeify(t)},Wallet.prototype.setLabel=function(e,t){e=e||{},common.validateParams(e,["address","label"],[],t);var r=this;if(!r.bitgo.verifyAddress({address:e.address}))throw new Error("Invalid bitcoin address: "+e.address);var n=this.bitgo.url("/labels/"+this.id()+"/"+e.address);return this.bitgo.put(n).send({label:e.label}).result().nodeify(t)},Wallet.prototype.deleteLabel=function(e,t){e=e||{},common.validateParams(e,["address"],[],t);var r=this;if(!r.bitgo.verifyAddress({address:e.address}))throw new Error("Invalid bitcoin address: "+e.address);var n=this.bitgo.url("/labels/"+this.id()+"/"+e.address);return this.bitgo.del(n).result().nodeify(t)},Wallet.prototype.unspents=function(e,t){if(e=e||{},common.validateParams(e,[],[],t),e.minConfirms&&"number"!=typeof e.minConfirms)throw new Error("invalid minConfirms - should be number");var r=[],n=this,i=function(t,a){var o=n.url("/unspents"),s={};if(e.instant?s.instant=e.instant:e.minConfirms&&(s.minConfirms=e.minConfirms),e.target){if("number"!=typeof e.target)throw new Error("invalid argument");s.target=e.target}else t>0&&(s.skip=t),a&&a>0&&(s.limit=a);return n.bitgo.get(o).query(s).result().then(function(n){for(var o=0;o<n.unspents.length;o++){var s=n.unspents[o];r.push(s)}if(r.length>=e.limit)return r;var l=n.total;if(!e.target&&l&&l>r.length){var u=t+n.count,p=null;return a>0&&(p=a-r.length),i(u,p)}return r})};return i(0,e.limit).nodeify(t)},Wallet.prototype.unspentsPaged=function(e,t){if(e=e||{},common.validateParams(e,[],[],t),e.limit&&"number"!=typeof e.limit)throw new Error("invalid limit - should be number");if(e.skip&&"number"!=typeof e.skip)throw new Error("invalid skip - should be number");if(e.minConfirms&&"number"!=typeof e.minConfirms)throw new Error("invalid minConfirms - should be number");if(e.target&&"number"!=typeof e.target)throw new Error("invalid target - should be number");if(e.instant&&"boolean"!=typeof e.instant)throw new Error("invalid instant flag - should be boolean");return this.bitgo.get(this.url("/unspents")).query(e).result().nodeify(t)},Wallet.prototype.transactions=function(e,t){e=e||{},common.validateParams(e,[],[],t);var r=[];if(e.limit){if("number"!=typeof e.limit)throw new Error("invalid limit argument, expecting number");r.push("limit="+e.limit)}if(e.skip){if("number"!=typeof e.skip)throw new Error("invalid skip argument, expecting number");r.push("skip="+e.skip)}if(e.minHeight){if("number"!=typeof e.minHeight)throw new Error("invalid minHeight argument, expecting number");r.push("minHeight="+e.minHeight)}var n="";r.length&&(n="?"+r.join("&"));var i=this.url("/tx"+n);return this.bitgo.get(i).result().nodeify(t)},Wallet.prototype.getTransaction=function(e,t){e=e||{},common.validateParams(e,["id"],[],t);var r=this.url("/tx/"+e.id);return this.bitgo.get(r).result().nodeify(t)},Wallet.prototype.getWalletTransactionBySequenceId=function(e,t){e=e||{},common.validateParams(e,["sequenceId"],[],t);var r=this.url("/tx/sequence/"+e.sequenceId);return this.bitgo.get(r).result().nodeify(t)},Wallet.prototype.getEncryptedUserKeychain=function(e,t){e=e||{},common.validateParams(e,[],[],t);var r=this,n=function(e){if(!r.keychains||e>=r.keychains.length)return r.bitgo.reject("No encrypted keychains on this wallet.",t);var i={xpub:r.keychains[e].xpub};return r.bitgo.keychains().get(i).then(function(t){return t.walletSubPath=r.keychains[e].path,t.encryptedXprv?t:n(e+1)})};return n(0).nodeify(t)},Wallet.prototype.createTransaction=function(e,t){e=_.extend({},e),common.validateParams(e,[],[],t);if("number"!=typeof e.fee&&"undefined"!=typeof e.fee||"number"!=typeof e.feeRate&&"undefined"!=typeof e.feeRate||"number"!=typeof e.minConfirms&&"undefined"!=typeof e.minConfirms||"boolean"!=typeof e.forceChangeAtEnd&&"undefined"!=typeof e.forceChangeAtEnd||"string"!=typeof e.changeAddress&&"undefined"!=typeof e.changeAddress||"boolean"!=typeof e.validate&&"undefined"!=typeof e.validate||"boolean"!=typeof e.instant&&"undefined"!=typeof e.instant)throw new Error("invalid argument");if("object"==typeof e.keychain)throw new Error("createTransaction no longer takes a keychain to perform signing - please use signTransaction to sign");if("object"!=typeof e.recipients)throw new Error("expecting recipients object");return e.validate=void 0!==e.validate?e.validate:this.bitgo.getValidate(),e.wallet=this,TransactionBuilder.createTransaction(e).nodeify(t)},Wallet.prototype.signTransaction=function(e,t){e=_.extend({},e),common.validateParams(e,["transactionHex"],[],t);if(!Array.isArray(e.unspents))throw new Error("expecting the unspents array");if(("object"!=typeof e.keychain||!e.keychain.xprv)&&"string"!=typeof e.signingKey)throw new Error("expecting keychain object with xprv");return e.validate=void 0!==e.validate?e.validate:this.bitgo.getValidate(),TransactionBuilder.signTransaction(e).then(function(e){return{tx:e.transactionHex}}).nodeify(t)},Wallet.prototype.sendTransaction=function(e,t){e=e||{},common.validateParams(e,["tx"],["message"],t);return this.bitgo.post(this.bitgo.url("/tx/send")).send(e).result().then(function(e){return e.pendingApproval?_.extend(e,{status:"pendingApproval"}):{status:"accepted",tx:e.transaction,hash:e.transactionHash,instant:e.instant,instantId:e.instantId}}).nodeify(t)},Wallet.prototype.createShare=function(e,t){if(e=e||{},common.validateParams(e,["user","permissions"],[],t),e.keychain&&!_.isEmpty(e.keychain)&&!(e.keychain.xpub&&e.keychain.encryptedXprv&&e.keychain.fromPubKey&&e.keychain.toPubKey&&e.keychain.path))throw new Error("requires keychain parameters - xpub, encryptedXprv, fromPubKey, toPubKey, path");return this.bitgo.post(this.url("/share")).send(e).result().nodeify(t)},Wallet.prototype.sendCoins=function(e,t){if(e=e||{},common.validateParams(e,["address"],["message"],t),"number"!=typeof e.amount)throw new Error("invalid argument for amount - number expected");return e.recipients={},e.recipients[e.address]=e.amount,this.sendMany(e).nodeify(t)},Wallet.prototype.sendMany=function(e,t){e=e||{},common.validateParams(e,[],["message"],t);var r=this;if("object"!=typeof e.recipients)throw new Error("expecting recipients object");if(e.fee&&"number"!=typeof e.fee)throw new Error("invalid argument for fee - number expected");if(e.feeRate&&"number"!=typeof e.feeRate)throw new Error("invalid argument for feeRate - number expected");if(e.instant&&"boolean"!=typeof e.instant)throw new Error("invalid argument for instant - boolean expected");var n,i,a;return this.createAndSignTransaction(e).then(function(t){return n=t.fee,i=t.feeRate,a=t.instantFee,r.sendTransaction({tx:t.tx,message:e.message,sequenceId:e.sequenceId,instant:e.instant})}).then(function(e){return e.fee=n,e.feeRate=i,a&&(e.instantFee=a),e}).nodeify(t)},Wallet.prototype.createAndSignTransaction=function(e,t){e=e||{},common.validateParams(e,[],[],t);var r=this;if("object"!=typeof e.recipients)throw new Error("expecting recipients object");if(e.fee&&"number"!=typeof e.fee)throw new Error("invalid argument for fee - number expected");if(e.feeRate&&"number"!=typeof e.feeRate)throw new Error("invalid argument for feeRate - number expected");if(e.dynamicFeeConfirmTarget&&"number"!=typeof e.dynamicFeeConfirmTarget)throw new Error("invalid argument for confirmTarget - number expected");if(e.instant&&"boolean"!=typeof e.instant)throw new Error("invalid argument for instant - boolean expected");var n,i,a;return Q().then(function(){return Q.all([r.getAndPrepareSigningKeychain(e),r.createTransaction(e)])}).spread(function(t,o){return n=o.fee,i=o.feeRate,o.keychain=t,a=o.instantFee,o.feeSingleKeyWIF=e.feeSingleKeyWIF,r.signTransaction(o)}).then(function(t){return _.extend(t,{fee:n,feeRate:i,instant:e.instant,instantFee:a})}).nodeify(t)},Wallet.prototype.getAndPrepareSigningKeychain=function(e,t){if(e=e||{},common.validateParams(e,[],["walletPassphrase","xprv"],t),e.walletPassphrase&&e.xprv||!e.walletPassphrase&&!e.xprv)throw new Error("must provide exactly one of xprv or walletPassphrase");var r=this;if(e.walletPassphrase)return r.getEncryptedUserKeychain().then(function(t){try{t.xprv=r.bitgo.decrypt({password:e.walletPassphrase,input:t.encryptedXprv})}catch(n){throw new Error("Unable to decrypt user keychain")}return t});var n;try{n=HDNode.fromBase58(e.xprv).neutered().toBase58()}catch(i){throw new Error("Unable to parse the xprv")}if(n==e.xprv)throw new Error("xprv provided was not a private key (found xpub instead)");var a=_.pluck(r.keychains,"xpub");if(!_.includes(a,n))throw new Error("xprv provided was not a keychain on this wallet!");return r.bitgo.keychains().get({xpub:n}).then(function(t){return t.xprv=e.xprv,t})},Wallet.prototype.fanOutUnspents=function(e,t){var r=80,n=300;e=e||{},common.validateParams(e,[],["walletPassphrase","xprv"],t);var i=void 0===e.validate?!0:e.validate,a=e.target;if("number"!=typeof a||2>a||a%1!==0)throw new Error("Target needs to be a positive integer");if(a>n)throw new Error("Fan out target too high");var o,s=this,l=function(e,t){var r=Math.floor(e/t),n=e-r*t,i=new Array(t);return _.fill(i,r+1,0,n),_.fill(i,r,n),assert.equal(_(i).sum(),e),assert.equal(_(i).size(),t),i},u=0;return s.unspents({minConfirms:e.minConfirms}).then(function(t){if(t.length<1)throw new Error("No unspents to branch out");if(t.length>=a)throw new Error("Fan out target has to be bigger than current number of unspents");if(t.length>r)throw new Error("Too many unspents");u=_(t).pluck("value").sum(),o=_.extend({},e),o.unspents=t,o.recipients={};var n=[];return _.range(a).reduce(function(e){return e.then(function(){return s.createAddress({chain:1,validate:i})}).then(function(e){return n.push(e),n})},Q())}).then(function(e){var t=l(u,a);return o.recipients=_.zipObject(_.pluck(e,"address"),t),o.splitChangeSize=0,s.sendMany(o)["catch"](function(t){if(!(t.fee||t.result&&t.result.fee))throw t;var r=t.fee||t.result.fee;o.fee=r;var n=u-r,i=l(n,a);return o.recipients=_.zipObject(_.pluck(e,"address"),i),s.sendMany(o)})}).nodeify(t)},Wallet.prototype.consolidateUnspents=function(e,t){e=e||{},common.validateParams(e,[],["walletPassphrase","xprv"],t);var r=void 0===e.validate?!0:e.validate,n=e.target;if(void 0===n)n=1;else if("number"!=typeof n||1>n||n%1!==0)throw new Error("Target needs to be a positive integer");var i=85,a=e.maxInputCountPerConsolidation;if(void 0===a&&(a=i),"number"!=typeof a||2>a||a%1!==0)throw new Error("Maximum consolidation input count needs to be an integer equal to or bigger than 2");if(a>i)throw new Error("Maximum consolidation input count cannot be bigger than "+i);var o=this,s=0,l=function(){var t,i,u,p=[],d=!1;return o.unspents({limit:n+a,minConfirms:e.minConfirms}).then(function(e){if(e.length<=n)throw new Error("Fewer unspents than consolidation target. Use fanOutUnspents instead.");var t=e.length-n+1;i=Math.min(t,a),d=i===t;var s=e.splice(0,i);return[o.createAddress({chain:1,validate:r}),s]}).spread(function(r,n){var i=_.extend({},e);return u=r,t=_(n).pluck("value").sum(),i.unspents=n,i.recipients={},i.recipients[r.address]=t,i.splitChangeSize=0,o.sendMany(i)["catch"](function(e){if(!(e.fee||e.result&&e.result.fee))throw e;var n=e.fee||e.result.fee,a=t-n;return delete i.fee,delete i.feeRate,delete i.feeTxConfirmTarget,i.fee=n,i.recipients[r.address]=a,o.sendMany(i)})}).then(function(r){return p.push(r),"function"==typeof e.progressCallback&&e.progressCallback({txid:r.hash,destination:u,amount:t,fee:r.fee,inputCount:i,index:s}),s++,d?p:Q.delay(1e3).then(l)})};return l(this,n).nodeify(t)},Wallet.prototype.shareWallet=function(e,t){if(e=e||{},common.validateParams(e,["email","permissions"],["walletPassphrase","message"],t),void 0!==e.reshare&&"boolean"!=typeof e.reshare)throw new Error("Expected reshare to be a boolean.");if(void 0!==e.skipKeychain&&"boolean"!=typeof e.skipKeychain)throw new Error("Expected skipKeychain to be a boolean. ");var r,n,i=!e.skipKeychain&&-1!==e.permissions.indexOf("spend"),a=this;return this.bitgo.getSharingKey({email:e.email}).then(function(t){return r=t,i?a.getEncryptedUserKeychain({}).then(function(t){if(t.encryptedXprv){if(!e.walletPassphrase)throw new Error("Missing walletPassphrase argument");try{t.xprv=a.bitgo.decrypt({password:e.walletPassphrase,input:t.encryptedXprv})}catch(i){throw new Error("Unable to decrypt user keychain")}var o=ECKey.makeRandom(),s=a.bitgo.getECDHSecret({eckey:o,otherPubKeyHex:r.pubkey}),l=a.bitgo.encrypt({password:s,input:t.xprv});n={xpub:t.xpub,encryptedXprv:l,fromPubKey:o.pub.toHex(),toPubKey:r.pubkey,path:r.path}}}):void 0}).then(function(){var t={user:r.userId,permissions:e.permissions,reshare:e.reshare,message:e.message};return n?t.keychain=n:e.skipKeychain&&(t.keychain={}),a.createShare(t)}).nodeify(t)},Wallet.prototype.removeUser=function(e,t){return e=e||{},common.validateParams(e,["user"],[],t),this.bitgo.del(this.url("/user/"+e.user)).send().result().nodeify(t)},Wallet.prototype.getPolicy=function(e,t){return e=e||{},common.validateParams(e,[],[],t),this.bitgo.get(this.url("/policy")).send().result().nodeify(t)},Wallet.prototype.getPolicyStatus=function(e,t){return e=e||{},common.validateParams(e,[],[],t),this.bitgo.get(this.url("/policy/status")).send().result().nodeify(t)},Wallet.prototype.setPolicyRule=function(e,t){if(e=e||{},common.validateParams(e,["id","type"],["message"],t),"object"!=typeof e.condition)throw new Error("missing parameter: conditions object");if("object"!=typeof e.action)throw new Error("missing parameter: action object");return this.bitgo.put(this.url("/policy/rule")).send(e).result().nodeify(t)},Wallet.prototype.removePolicyRule=function(e,t){return e=e||{},common.validateParams(e,["id"],["message"],t),this.bitgo.del(this.url("/policy/rule")).send(e).result().nodeify(t)},Wallet.prototype.listWebhooks=function(e,t){return e=e||{},common.validateParams(e,[],[],t),this.bitgo.get(this.url("/webhooks")).send().result().nodeify(t)},Wallet.prototype.addWebhook=function(e,t){return e=e||{},common.validateParams(e,["url","type"],[],t),this.bitgo.post(this.url("/webhooks")).send(e).result().nodeify(t)},Wallet.prototype.removeWebhook=function(e,t){return e=e||{},common.validateParams(e,["url","type"],[],t),this.bitgo.del(this.url("/webhooks")).send(e).result().nodeify(t)},Wallet.prototype.estimateFee=function(e,t){return this.bitgo.estimateFee(e)},Wallet.prototype.updatePolicyRule=function(e,t){return e=e||{},common.validateParams(e,["id","type"],[],t),this.bitgo.put(this.url("/policy/rule")).send(e).result().nodeify(t)},Wallet.prototype.deletePolicyRule=function(e,t){return e=e||{},common.validateParams(e,["id"],[],t),this.bitgo.del(this.url("/policy/rule")).send(e).result().nodeify(t)},module.exports=Wallet;